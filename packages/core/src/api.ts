/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/{teamId}/projects/slug/{slug}": {
    /**
     * Get project by slug
     * @description Gets a project by a unique slug.
     */
    get: operations["projects-getBySlug"];
  };
  "/{teamId}/projects/{id}": {
    /**
     * Get project
     * @description Gets a project by a unique ID.
     */
    get: operations["projects-getById"];
    /**
     * Delete project
     * @description Deletes a project by ID.
     */
    delete: operations["projects-delete"];
    /**
     * Update project
     * @description Updates a project by ID.
     */
    patch: operations["projects-update"];
  };
  "/{teamId}/projects": {
    /**
     * List projects
     * @description Lists projects within a team.
     */
    get: operations["projects-list"];
    /**
     * Create project
     * @description Create a project for a team. Projects are used to categorize resources within Moonbase.
     */
    post: operations["projects-create"];
  };
  "/tokens": {
    /**
     * Create token
     * @description Create an API token for use in Moonbase
     */
    post: operations["tokens-create"];
  };
  "/logs/{id}": {
    /**
     * Get team logs
     * @description Gets logs for a given team
     */
    get: operations["logs-getSingle"];
  };
  "/logs": {
    /**
     * Get team logs
     * @description Gets logs for a given team
     */
    get: operations["logs-list"];
    /**
     * Ingest logs
     * @description Ingests log messages for a team.
     */
    post: operations["logs-create"];
  };
  "/logs/count": {
    /**
     * Count daily logs
     * @description Gets a daily aggreagtion of logs for a given team.
     */
    get: operations["logs-count"];
  };
  "/logs/total": {
    /**
     * Total Log Count
     * @description Gets the total of all logs collected and held in Moonbase.
     */
    get: operations["logs-total"];
  };
  "/logs/total/usage": {
    /**
     * Total Log Usage
     * @description Gets the total in bytes of all logs collected and held in Moonbase.
     */
    get: operations["logs-usageTotal"];
  };
  "/logs/total/interval": {
    /**
     * Total Log Usage
     * @description Gets the occurrence of logs across a timeline, grouped by date interval.
     */
    get: operations["logs-interval"];
  };
  "/logs/attributes": {
    /**
     * Active log attributes
     * @description Gets all active log attributes across the team. Used for suggestions in the query builder..
     */
    get: operations["logs-attributes"];
  };
  "/projects/{id}/alerts/{alertId}": {
    /**
     * Get project
     * @description Gets a alert by a unique ID.
     */
    get: operations["alerts-getById"];
    /**
     * Delete alert
     * @description Deletes an alert by ID.
     */
    delete: operations["alerts-delete"];
    /**
     * Update Alert
     * @description Updates an alert by ID.
     */
    patch: operations["alerts-update"];
  };
  "/projects/{id}/alerts": {
    /**
     * Create alert
     * @description Create an alert for a team.
     */
    post: operations["alerts-create"];
  };
  "/{teamId}/alerts": {
    /**
     * List Alerts
     * @description Lists all alerts within a team.
     */
    get: operations["alerts-list"];
  };
  "/integrations": {
    /**
     * List Integrations
     * @description Lists all available Moonbase integration types.
     */
    get: operations["integrationTypes-list"];
  };
  "/teams/{teamId}/configs": {
    /**
     * Create Integration Configuration
     * @description Creates an integration configuration for a given team
     */
    post: operations["integrationConfigs-create"];
  };
  "/teams/{teamId}/configs/{configId}": {
    /**
     * Delete Integration Configuration
     * @description Deletes an integration configuration for a given team.
     */
    delete: operations["integrationConfigs-delete"];
    /**
     * Update Integration Configuration
     * @description Updates an integration configuration for a team.
     */
    patch: operations["integrationConfigs-update"];
  };
  "/teams/{teamId}/integrations/{integrationId}": {
    /**
     * Read Integration Configuration
     * @description Reads an integration configuration for a team.
     */
    get: operations["integrationConfigs-read"];
  };
  "/health": {
    /**
     * Health check
     * @description Check if the API is healthy.
     */
    get: operations["health"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: never;
  responses: {
    /** @description Error response */
    error: {
      content: {
        "application/json": {
          message: string;
          code: string;
          issues?: {
              message: string;
            }[];
        };
      };
    };
  };
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /**
   * Get project by slug
   * @description Gets a project by a unique slug.
   */
  "projects-getBySlug": {
    parameters: {
      path: {
        /** @description ID of the team that the project belongs to. */
        teamId: string;
        /** @description Unique slug of the project being fetched. */
        slug: string;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            id: string;
            name: string | null;
            teamId: string;
            slug: string;
            description: string | null;
            environment: string | null;
            /** Format: date-time */
            createdAt: string;
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  /**
   * Get project
   * @description Gets a project by a unique ID.
   */
  "projects-getById": {
    parameters: {
      path: {
        /** @description ID of the team that the project belongs to. */
        teamId: string;
        /** @description ID of the project being fetched. */
        id: string;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            id: string;
            name: string | null;
            teamId: string;
            slug: string;
            description: string | null;
            environment: string | null;
            /** Format: date-time */
            createdAt: string;
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  /**
   * Delete project
   * @description Deletes a project by ID.
   */
  "projects-delete": {
    parameters: {
      path: {
        /** @description ID of the project being deleted. */
        id: string;
        /** @description ID of the team that the project belongs to. */
        teamId: string;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      default: components["responses"]["error"];
    };
  };
  /**
   * Update project
   * @description Updates a project by ID.
   */
  "projects-update": {
    parameters: {
      path: {
        /** @description ID of the project being updated. */
        id: string;
        /** @description ID of the team that the project belongs to. */
        teamId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Name of a project */
          name: string | null;
          /** @description A helpful description of the project. */
          description: string | null;
          /** @description The environment that the project lives in. */
          environment: string | null;
        };
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            id: string;
            name: string | null;
            teamId: string;
            slug: string;
            description: string | null;
            environment: string | null;
            /** Format: date-time */
            createdAt: string;
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  /**
   * List projects
   * @description Lists projects within a team.
   */
  "projects-list": {
    parameters: {
      query?: {
        take?: unknown;
        after?: string;
      };
      path: {
        /** @description ID of the team that the project belongs to. */
        teamId: string;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            nodes: ({
                id: string;
                name: string | null;
                teamId: string;
                slug: string;
                description: string | null;
                environment: string | null;
                /** Format: date-time */
                createdAt: string;
              })[];
            pageInfo: {
              hasNextPage: boolean;
              hasPreviousPage: boolean;
              startCursor: string | null;
              endCursor: string | null;
            };
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  /**
   * Create project
   * @description Create a project for a team. Projects are used to categorize resources within Moonbase.
   */
  "projects-create": {
    parameters: {
      path: {
        /** @description ID of the team that the project belongs to. */
        teamId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Name of the project */
          name: string;
          /** @description A helpful description of the project. */
          description: string | null;
          /** @description The environment that the project lives in. */
          environment: string | null;
        };
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            id: string;
            name: string | null;
            teamId: string;
            slug: string;
            description: string | null;
            environment: string | null;
            /** Format: date-time */
            createdAt: string;
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  /**
   * Create token
   * @description Create an API token for use in Moonbase
   */
  "tokens-create": {
    requestBody: {
      content: {
        "application/json": {
          teamId: string;
          name: string;
          /** Format: date-time */
          expiresAt: string | null;
        };
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            id: string;
            name: string;
            /** Format: date-time */
            expiresAt?: string | null;
            /** Format: date-time */
            lastUsedAt?: string | null;
            /** Format: date-time */
            createdAt: string;
            /** Format: date-time */
            deletedAt?: string | null;
            token: string;
            user: {
              email: string;
            };
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  /**
   * Get team logs
   * @description Gets logs for a given team
   */
  "logs-getSingle": {
    parameters: {
      query?: {
        teamId?: string;
      };
      path: {
        /** @description The id of the log */
        id: string;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            body: string | {
              [key: string]: unknown;
            };
            level?: string;
            /** @default 0 */
            usageBytes?: string;
            hostname?: string;
            service?: string;
            /** Format: date-time */
            timestamp?: string;
            attributes?: {
              [key: string]: string;
            };
            userId: string;
            teamId: string;
            project: {
              /** @description The ID of the project associated with the log */
              id: string;
              /** @description The name of the project */
              name: string;
              /** @description The type of project */
              type: string | null;
              /** @description Project environment */
              environment: string | null;
            };
            user: {
              /** @description The display name of the user who committed the log */
              displayName: string;
            };
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  /**
   * Get team logs
   * @description Gets logs for a given team
   */
  "logs-list": {
    parameters: {
      query?: {
        /** @description A search query to find logs by. */
        q?: unknown;
        /** @description Comma delimited list of projectIds. Ex 'cuid1,cuid2,cuid3'. */
        projectIds?: unknown;
        start?: string;
        end?: string;
        /** @description Indicates the next offset to start searching from. */
        cursor?: unknown;
        teamId?: string;
        limit?: unknown;
        rel?: "30_min" | "60_min" | "3_hours" | "6_hours" | "12_hours" | "24_hours" | "2_days" | "7_days" | "30_days";
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            /** @description A list of logs. */
            data: ({
                body: string | {
                  [key: string]: unknown;
                };
                level?: string;
                /** @default 0 */
                usageBytes?: string;
                hostname?: string;
                service?: string;
                /** Format: date-time */
                timestamp?: string;
                attributes?: {
                  [key: string]: string;
                };
                userId: string;
                teamId: string;
                /** Format: uuid */
                uuid: string;
              })[];
            /**
             * @description Indicates the next offset to start searching from.
             * @default null
             */
            cursor?: string | null;
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  /**
   * Ingest logs
   * @description Ingests log messages for a team.
   */
  "logs-create": {
    requestBody: {
      content: {
        "application/json": {
          data: ({
              body: string | {
                [key: string]: unknown;
              };
              level?: string;
              /** @default 0 */
              usageBytes?: string;
              hostname?: string;
              service?: string;
              /** Format: date-time */
              timestamp?: string;
              attributes?: {
                [key: string]: string;
              };
            })[];
          /** @description ID of the project that the log is for. */
          projectId?: string;
          /** @description ID of the team that the logs belongs to. */
          teamId?: string;
        };
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            success: boolean;
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  /**
   * Count daily logs
   * @description Gets a daily aggreagtion of logs for a given team.
   */
  "logs-count": {
    parameters: {
      query: {
        teamId?: string;
        metric: "30_day" | "60_day";
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
              count: number;
              date: string;
            }[];
        };
      };
      default: components["responses"]["error"];
    };
  };
  /**
   * Total Log Count
   * @description Gets the total of all logs collected and held in Moonbase.
   */
  "logs-total": {
    parameters: {
      query?: {
        teamId?: string;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            count: string;
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  /**
   * Total Log Usage
   * @description Gets the total in bytes of all logs collected and held in Moonbase.
   */
  "logs-usageTotal": {
    parameters: {
      query?: {
        teamId?: string;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            usage: string;
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  /**
   * Total Log Usage
   * @description Gets the occurrence of logs across a timeline, grouped by date interval.
   */
  "logs-interval": {
    parameters: {
      query?: {
        teamId?: string;
        rel?: "30_min" | "60_min" | "3_hours" | "6_hours" | "12_hours" | "24_hours" | "2_days" | "7_days" | "30_days";
        start?: string;
        end?: string;
        /** @description A search query to find logs by. */
        q?: unknown;
        /** @description Comma delimited list of projectIds. Ex 'cuid1,cuid2,cuid3'. */
        projectIds?: unknown;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
              other: number;
              date: string;
              error: number;
            }[];
        };
      };
      default: components["responses"]["error"];
    };
  };
  /**
   * Active log attributes
   * @description Gets all active log attributes across the team. Used for suggestions in the query builder..
   */
  "logs-attributes": {
    parameters: {
      query?: {
        teamId?: string;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
              /** @description The key of the attribute within Moonbase. */
              key: string;
              /** @description The count of occurences of the attribute key */
              occurences: string;
            }[];
        };
      };
      default: components["responses"]["error"];
    };
  };
  /**
   * Get project
   * @description Gets a alert by a unique ID.
   */
  "alerts-getById": {
    parameters: {
      path: {
        /** @description ID of the project that the alert belongs to. */
        id: string;
        /** @description ID of the alert being fetched. */
        alertId: string;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            id: string;
            name: string | null;
            query: string;
            projectId: string;
            userId: string;
            /** Format: date-time */
            lastNotifiedAt: string;
            /** Format: date-time */
            createdAt: string;
            /** Format: date-time */
            deletedAt: string | null;
            /** @default v0 */
            lang_version?: string;
            /** @enum {string} */
            type: "log";
            /** @enum {string} */
            buffer: "min_15" | "min_30" | "hr_1" | "hr_3" | "hr_6";
            /** @enum {string} */
            state: "normal" | "warning" | "alerting";
            /** @default true */
            enabled?: boolean;
            alertJobs: ({
                id: string;
                alertId: string;
                error: string | null;
                state: string;
                /** Format: date-time */
                acknowlegedAt?: string;
                value: number;
                acknowlegedBy?: {
                  id: string;
                  /** Format: email */
                  email: string;
                };
                /** @enum {string} */
                alertState: "normal" | "warning" | "alerting";
                /** Format: date-time */
                createdAt: string;
              })[];
            alertStrategies: ({
                /** @enum {string} */
                comparator: "gt" | "eq" | "lt" | "lte" | "gte";
                value: number;
                /** @enum {string} */
                pendingPeriod: "none" | "min_1" | "min_5" | "min_10" | "min_15" | "min_30" | "hr_1" | "hr_6";
                /** @enum {string} */
                interval: "sec_30" | "min_1" | "min_2" | "min_5" | "min_10" | "min_30" | "hr_1" | "hr_3" | "hr_6" | "hr_12";
              })[];
            alertIntegrations: {
                id: string;
                alertId: string;
                integration: {
                  id: string;
                  /** Format: date-time */
                  createdAt: string;
                  enabled: boolean;
                  config: {
                    [key: string]: unknown;
                  };
                  integration: {
                    id: string;
                    name: string;
                    type: string;
                  };
                };
                /** Format: date-time */
                createdAt: string;
              }[];
            project: {
              id: string;
              name: string | null;
              teamId: string;
              slug: string;
              description: string | null;
              environment: string | null;
              /** Format: date-time */
              createdAt: string;
            };
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  /**
   * Delete alert
   * @description Deletes an alert by ID.
   */
  "alerts-delete": {
    parameters: {
      path: {
        /** @description ID of the project that the alert belongs to. */
        id: string;
        /** @description ID of the alert that is being deleted */
        alertId: string;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      default: components["responses"]["error"];
    };
  };
  /**
   * Update Alert
   * @description Updates an alert by ID.
   */
  "alerts-update": {
    parameters: {
      path: {
        /** @description The ID of the project that owns the alert. */
        id: string;
        /** @description ID of the alert that is being deleted */
        alertId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          update: {
            /** @description Name of the alert */
            name?: string;
            /** @description The query used for the alert. */
            query?: string;
            /**
             * @description The enabled state of the alert
             * @default true
             */
            enabled?: boolean;
            strategy?: {
              /**
               * @description The comparator for the alert strategy.
               * @enum {string}
               */
              comparator?: "gt" | "eq" | "lt" | "lte" | "gte";
              /**
               * @description The pending period for the alert strategy. An alert will first transition to pending until this period is elapsed. Value set to 'none' by default.
               * @enum {string}
               */
              pendingPeriod?: "none" | "min_1" | "min_5" | "min_10" | "min_15" | "min_30" | "hr_1" | "hr_6";
              /** @description The value of the alert strategy */
              value?: number;
              /**
               * @description The interval that the alert strategy runs on.
               * @enum {string}
               */
              interval?: "sec_30" | "min_1" | "min_2" | "min_5" | "min_10" | "min_30" | "hr_1" | "hr_3" | "hr_6" | "hr_12";
            };
            /**
             * @description How long of a buffer should exist before firing another alert.
             * @enum {string}
             */
            buffer?: "min_15" | "min_30" | "hr_1" | "hr_3" | "hr_6";
            /** @description The ID of the integration configuration to use for the alert. */
            integrationConfigId?: string;
          };
        };
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            id: string;
            name: string | null;
            query: string;
            projectId: string;
            userId: string;
            /** Format: date-time */
            lastNotifiedAt: string;
            /** Format: date-time */
            createdAt: string;
            /** Format: date-time */
            deletedAt: string | null;
            /** @default v0 */
            lang_version?: string;
            /** @enum {string} */
            type: "log";
            /** @enum {string} */
            buffer: "min_15" | "min_30" | "hr_1" | "hr_3" | "hr_6";
            /** @enum {string} */
            state: "normal" | "warning" | "alerting";
            /** @default true */
            enabled?: boolean;
            alertJobs: ({
                id: string;
                alertId: string;
                error: string | null;
                state: string;
                /** Format: date-time */
                acknowlegedAt?: string;
                value: number;
                acknowlegedBy?: {
                  id: string;
                  /** Format: email */
                  email: string;
                };
                /** @enum {string} */
                alertState: "normal" | "warning" | "alerting";
                /** Format: date-time */
                createdAt: string;
              })[];
            alertStrategies: ({
                /** @enum {string} */
                comparator: "gt" | "eq" | "lt" | "lte" | "gte";
                value: number;
                /** @enum {string} */
                pendingPeriod: "none" | "min_1" | "min_5" | "min_10" | "min_15" | "min_30" | "hr_1" | "hr_6";
                /** @enum {string} */
                interval: "sec_30" | "min_1" | "min_2" | "min_5" | "min_10" | "min_30" | "hr_1" | "hr_3" | "hr_6" | "hr_12";
              })[];
            alertIntegrations: {
                id: string;
                alertId: string;
                integration: {
                  id: string;
                  /** Format: date-time */
                  createdAt: string;
                  enabled: boolean;
                  config: {
                    [key: string]: unknown;
                  };
                  integration: {
                    id: string;
                    name: string;
                    type: string;
                  };
                };
                /** Format: date-time */
                createdAt: string;
              }[];
            project: {
              id: string;
              name: string | null;
              teamId: string;
              slug: string;
              description: string | null;
              environment: string | null;
              /** Format: date-time */
              createdAt: string;
            };
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  /**
   * Create alert
   * @description Create an alert for a team.
   */
  "alerts-create": {
    parameters: {
      path: {
        /** @description The ID of the project that owns the alert. */
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Name of the alert */
          name: string;
          /** @description The query used for the alert. */
          query: string;
          strategy: {
            /**
             * @description The type of alert strategy. Threshold is only supported right now.
             * @default threshold
             * @enum {string}
             */
            type?: "threshold" | "change" | "anomlay";
            /**
             * @description The comparator for the alert strategy.
             * @enum {string}
             */
            comparator: "gt" | "eq" | "lt" | "lte" | "gte";
            /**
             * @description The pending period for the alert strategy. An alert will first transition to pending until this period is elapsed. Value set to 'none' by default.
             * @enum {string}
             */
            pendingPeriod: "none" | "min_1" | "min_5" | "min_10" | "min_15" | "min_30" | "hr_1" | "hr_6";
            /** @description The value of the alert strategy */
            value: number;
            /**
             * @description The interval that the alert strategy runs on.
             * @enum {string}
             */
            interval: "sec_30" | "min_1" | "min_2" | "min_5" | "min_10" | "min_30" | "hr_1" | "hr_3" | "hr_6" | "hr_12";
          };
          /**
           * @description How long of a buffer should exist before firing another alert.
           * @enum {string}
           */
          buffer: "min_15" | "min_30" | "hr_1" | "hr_3" | "hr_6";
          /** @description The ID of the integration configuration to use for the alert. */
          integrationConfigId: string;
          /**
           * @description The type of alert. Defaults to log alert.
           * @default log
           * @enum {string}
           */
          type?: "log";
        };
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            id: string;
            name: string | null;
            query: string;
            projectId: string;
            userId: string;
            /** Format: date-time */
            lastNotifiedAt: string;
            /** Format: date-time */
            createdAt: string;
            /** Format: date-time */
            deletedAt: string | null;
            /** @default v0 */
            lang_version?: string;
            /** @enum {string} */
            type: "log";
            /** @enum {string} */
            buffer: "min_15" | "min_30" | "hr_1" | "hr_3" | "hr_6";
            /** @enum {string} */
            state: "normal" | "warning" | "alerting";
            /** @default true */
            enabled?: boolean;
            alertJobs: ({
                id: string;
                alertId: string;
                error: string | null;
                state: string;
                /** Format: date-time */
                acknowlegedAt?: string;
                value: number;
                acknowlegedBy?: {
                  id: string;
                  /** Format: email */
                  email: string;
                };
                /** @enum {string} */
                alertState: "normal" | "warning" | "alerting";
                /** Format: date-time */
                createdAt: string;
              })[];
            alertStrategies: ({
                /** @enum {string} */
                comparator: "gt" | "eq" | "lt" | "lte" | "gte";
                value: number;
                /** @enum {string} */
                pendingPeriod: "none" | "min_1" | "min_5" | "min_10" | "min_15" | "min_30" | "hr_1" | "hr_6";
                /** @enum {string} */
                interval: "sec_30" | "min_1" | "min_2" | "min_5" | "min_10" | "min_30" | "hr_1" | "hr_3" | "hr_6" | "hr_12";
              })[];
            alertIntegrations: {
                id: string;
                alertId: string;
                integration: {
                  id: string;
                  /** Format: date-time */
                  createdAt: string;
                  enabled: boolean;
                  config: {
                    [key: string]: unknown;
                  };
                  integration: {
                    id: string;
                    name: string;
                    type: string;
                  };
                };
                /** Format: date-time */
                createdAt: string;
              }[];
            project: {
              id: string;
              name: string | null;
              teamId: string;
              slug: string;
              description: string | null;
              environment: string | null;
              /** Format: date-time */
              createdAt: string;
            };
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  /**
   * List Alerts
   * @description Lists all alerts within a team.
   */
  "alerts-list": {
    parameters: {
      query?: {
        take?: unknown;
        after?: string;
      };
      path: {
        /** @description ID of the team that the alerts belongs to. */
        teamId: string;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            nodes: ({
                id: string;
                name: string | null;
                query: string;
                projectId: string;
                userId: string;
                /** Format: date-time */
                lastNotifiedAt: string;
                /** Format: date-time */
                createdAt: string;
                /** Format: date-time */
                deletedAt: string | null;
                /** @default v0 */
                lang_version?: string;
                /** @enum {string} */
                type: "log";
                /** @enum {string} */
                buffer: "min_15" | "min_30" | "hr_1" | "hr_3" | "hr_6";
                /** @enum {string} */
                state: "normal" | "warning" | "alerting";
                /** @default true */
                enabled?: boolean;
                alertJobs: ({
                    id: string;
                    alertId: string;
                    error: string | null;
                    state: string;
                    /** Format: date-time */
                    acknowlegedAt?: string;
                    value: number;
                    acknowlegedBy?: {
                      id: string;
                      /** Format: email */
                      email: string;
                    };
                    /** @enum {string} */
                    alertState: "normal" | "warning" | "alerting";
                    /** Format: date-time */
                    createdAt: string;
                  })[];
                alertStrategies: ({
                    /** @enum {string} */
                    comparator: "gt" | "eq" | "lt" | "lte" | "gte";
                    value: number;
                    /** @enum {string} */
                    pendingPeriod: "none" | "min_1" | "min_5" | "min_10" | "min_15" | "min_30" | "hr_1" | "hr_6";
                    /** @enum {string} */
                    interval: "sec_30" | "min_1" | "min_2" | "min_5" | "min_10" | "min_30" | "hr_1" | "hr_3" | "hr_6" | "hr_12";
                  })[];
                alertIntegrations: {
                    id: string;
                    alertId: string;
                    integration: {
                      id: string;
                      /** Format: date-time */
                      createdAt: string;
                      enabled: boolean;
                      config: {
                        [key: string]: unknown;
                      };
                      integration: {
                        id: string;
                        name: string;
                        type: string;
                      };
                    };
                    /** Format: date-time */
                    createdAt: string;
                  }[];
                project: {
                  id: string;
                  name: string | null;
                  teamId: string;
                  slug: string;
                  description: string | null;
                  environment: string | null;
                  /** Format: date-time */
                  createdAt: string;
                };
              })[];
            pageInfo: {
              hasNextPage: boolean;
              hasPreviousPage: boolean;
              startCursor: string | null;
              endCursor: string | null;
            };
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  /**
   * List Integrations
   * @description Lists all available Moonbase integration types.
   */
  "integrationTypes-list": {
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      default: components["responses"]["error"];
    };
  };
  /**
   * Create Integration Configuration
   * @description Creates an integration configuration for a given team
   */
  "integrationConfigs-create": {
    parameters: {
      path: {
        /** @description ID of the team that the log is for. */
        teamId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The configuration being created for the integration */
          config: {
            name: string;
            emails: string[];
          } | ({
            name: string;
            type: "s3-compatible" | "digitalocean";
            accessKeyId: string;
            secretKey: string;
            path: string;
            bucket: string;
            region: string;
            interval: "day" | "week" | "month";
          }) | {
            name: string;
          };
          /** @description The id of the integration */
          integrationId: string;
          projectIds: string[];
        };
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            /** @description The name of the team the configuration belongs to. */
            teamId: string;
            /**
             * Format: date-time
             * @description The date the config was deleted
             */
            deletedAt: string | null;
            /** @description The ID of the associated integration type. */
            integrationId: string;
            /** @description The ID of the integration configuration. */
            id: string;
            /** @description The parsed version of the encrypted configuration. */
            encryptedConfig?: unknown;
            /** @description Whether the config is enabled. */
            enabled: boolean;
            /** @description Potential error on the configuration. */
            error: string | null;
            /**
             * Format: date-time
             * @description Date when the config was created.
             */
            createdAt: string;
            /** @description Values for the configuration */
            config?: unknown;
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  /**
   * Delete Integration Configuration
   * @description Deletes an integration configuration for a given team.
   */
  "integrationConfigs-delete": {
    parameters: {
      path: {
        /** @description ID of the team that the configuration is for. */
        teamId: string;
        /** @description The id of the integration config to delete. */
        configId: string;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      default: components["responses"]["error"];
    };
  };
  /**
   * Update Integration Configuration
   * @description Updates an integration configuration for a team.
   */
  "integrationConfigs-update": {
    parameters: {
      path: {
        /** @description ID of the team that the log is for. */
        teamId: string;
        /** @description The id of the configuration to update. */
        configId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The configuration to upsert. */
          config: {
            name: string;
            emails: string[];
          } | ({
            name: string;
            type: "s3-compatible" | "digitalocean";
            accessKeyId: string;
            secretKey: string;
            path: string;
            bucket: string;
            region: string;
            interval: "day" | "week" | "month";
          }) | {
            name: string;
          };
          projectIds: string[];
        };
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            /** @description The name of the team the configuration belongs to. */
            teamId: string;
            /**
             * Format: date-time
             * @description The date the config was deleted
             */
            deletedAt: string | null;
            /** @description The ID of the associated integration type. */
            integrationId: string;
            /** @description The ID of the integration configuration. */
            id: string;
            /** @description The parsed version of the encrypted configuration. */
            encryptedConfig?: unknown;
            /** @description Whether the config is enabled. */
            enabled: boolean;
            /** @description Potential error on the configuration. */
            error: string | null;
            /**
             * Format: date-time
             * @description Date when the config was created.
             */
            createdAt: string;
            /** @description Values for the configuration */
            config?: unknown;
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  /**
   * Read Integration Configuration
   * @description Reads an integration configuration for a team.
   */
  "integrationConfigs-read": {
    parameters: {
      path: {
        /** @description ID of the team that the log is for. */
        teamId: string;
        /** @description The id of the integration */
        integrationId: string;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": ({
              /** @description The name of the team the configuration belongs to. */
              teamId: string;
              /** @description The configured projects. */
              projectIntegrations: {
                  projectId: string;
                }[];
              /**
               * Format: date-time
               * @description The date the config was deleted
               */
              deletedAt: string | null;
              /** @description The ID of the associated integration type. */
              integrationId: string;
              /** @description The ID of the integration configuration. */
              id: string;
              /** @description The parsed version of the encrypted configuration. */
              encryptedConfig?: unknown;
              /** @description Whether the config is enabled. */
              enabled: boolean;
              /** @description Potential error on the configuration. */
              error: string | null;
              /**
               * Format: date-time
               * @description Date when the config was created.
               */
              createdAt: string;
              /** @description Values for the configuration */
              config?: unknown;
              configJobs: ({
                  /**
                   * Format: date-time
                   * @description Completed time of the configuration job
                   */
                  completedAt: string | null;
                  /**
                   * Format: date-time
                   * @description When the config job was created
                   */
                  createdAt: string;
                  /** @description Potential error with the config job. */
                  error: string | null;
                  /** @description ID of the config job. */
                  id: string;
                  /** @description ID of the associated integration configuration. */
                  integrationConfigId: string;
                  /** @description Arbitrary output of the config job. */
                  output?: unknown;
                  /** @enum {string} */
                  state: "error" | "complete" | "pending";
                })[];
            })[];
        };
      };
      default: components["responses"]["error"];
    };
  };
  /**
   * Health check
   * @description Check if the API is healthy.
   */
  health: {
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": "HEALTHY";
        };
      };
      default: components["responses"]["error"];
    };
  };
}
